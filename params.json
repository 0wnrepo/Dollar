{"name":"Dollar and Cent","tagline":"Dollar is a functional tool-belt and Cent is an extension for missing methods in Swift","body":"![Introducing Dollar and Cent](https://raw.githubusercontent.com/ankurp/Dollar.swift/master/assets/hero.png)\r\n\r\nDollar is a Swift library that provides useful functional programming helper methods without extending any built in objects. It is similar to Lo-Dash or Underscore in Javascript.\r\n\r\nCent is a library that extends certain Swift object types using the extension feature and gives its two cents to Swift language.\r\n\r\n## Contents ##\r\n\r\n- [Setup](#setup)\r\n- Dollar\r\n  - [Usage](#dollar-usage)\r\n    - [Array](#array-methods)\r\n    - [Dictionary](#dictionary-methods)\r\n    - [Object](#object-methods)\r\n    - [Function](#function-methods)\r\n    - [Chaining](#chaining)\r\n  - [Examples](#dollar-examples)\r\n    - [Array](#array)\r\n    - [Dictionary](#dictionary)\r\n    - [Object](#object)\r\n    - [Function](#function)\r\n    - [Chaining](#chaining---array-)\r\n- Cent\r\n  - [Usage](#cent-usage)\r\n    - [Array](#array-extensions)\r\n    - [Date](#date-extensions)  \r\n    - [Dictionary](#dictionary-extensions)\r\n    - [Int](#int-extensions)\r\n    - [String](#string-extensions)\r\n    - [Range](#range-extensions)\r\n  - [Examples](#cent-examples)\r\n    - [Array](#array-example-usage)\r\n    - [Date](#date-example-usage)\r\n    - [Dictionary](#dictionary-example-usage)\r\n    - [Int](#int-example-usage)\r\n    - [String](#string-example-usage)\r\n    - [Range](#range-example-usage)\r\n- [Contributing](#contributing)\r\n- [Roadmap](#roadmap)\r\n- [Dollar or Cent?](#dollar-or-cent)\r\n\r\n## Setup ##\r\n\r\nCurrently there are issues loading the library using `pod 'Dollar'` which is pending changes from Cocoapods. In the mean time follow these steps\r\n\r\n1. If you are using git then add Dollar as a submodule using `git submodule add https://github.com/ankurp/Dollar.swift.git` otherwise download the project using `git clone https://github.com/ankurp/Dollar.swift.git` in your project folder.\r\n2. Open the Dollar.swift folder. Drag Dollar.xcodeproj, inside the Dollar folder, into the file navigator of your Xcode project.\r\n3. In Xcode, navigate to the target configuration window by clicking on the blue project icon, and selecting the application target under the \"Targets\" heading in the sidebar.\r\n4. In the tab bar at the top of that window, open the \"Build Phases\" panel.\r\n5. Expand the \"Link Binary with Libraries\" group, and add Dollar.framework.\r\n6. In your project file `import Dollar` and you can call all of the helper functions.\r\n\r\n![How to import library](https://raw.githubusercontent.com/ankurp/Dollar.swift/master/assets/HowToImport.gif)\r\n\r\n## Dollar Usage ##\r\n\r\n### Array Methods ###\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`$.at`**|Creates an array of elements from the specified indexes, or keys, of the collection. Indexes may be specified as individual arguments or as arrays of indexes.\r\n**`$.compact`**|Creates an array with all nil values removed.\r\n**`$.contains`**|Checks if a given value is present in the array.\r\n**`$.difference`**|Creates an array excluding all values of the provided arrays\r\n**`$.every`**|Checks if the given callback returns true value for all items in the array.\r\n**`$.find`**|Iterates over elements of an array and returning the first element that the callback returns true for.\r\n**`$.findIndex`**|This method is like find except that it returns the index of the first element that passes the callback check.\r\n**`$.findLastIndex`**|This method is like findIndex except that it iterates over elements of the array from right to left.\r\n**`$.first`**|Gets the first element in the array.\r\n**`$.second`**|Gets the second element in the array.\r\n**`$.third`**|Gets the third element in the array.\r\n**`$.flatten`**|Flattens a nested array of any depth.\r\n**`$.frequencies`**|This method returns a dictionary of values in an array mapping to the total number of occurrences in the array. If passed a function it returns a frequency table of the results of the given function on the arrays elements.\r\n**`$.indexOf`**|Gets the index at which the first occurrence of value is found.\r\n**`$.initial`**|Gets all but the last element or last n elements of an array.\r\n**`$.intersection`**|Creates an array of unique values present in all provided arrays.\r\n**`$.join`**|Joins the elements in the array to create a concatenated element of the same type.\r\n**`$.last`**|Gets the last element from the array.\r\n**`$.lastIndexOf`**|Gets the index at which the last occurrence of value is found.\r\n**`$.rest`**|The opposite of initial this method gets all but the first element or first n elements of an array.\r\n**`$.max`**|Retrieves the maximum value in an array.\r\n**`$.merge`**|Creates an array of all values, including duplicates, of the arrays in the order they are provided.\r\n**`$.min`**|Retrieves the minimum value in an array.\r\n**`$.pluck`**|Retrieves the value of a specified property from all elements in the array.\r\n**`$.pull`**|Removes all provided values from the given array.\r\n**`$.range`**|Creates an array of numbers (positive and/or negative) progressing from start up to but not including end.\r\n**`$.sequence`**|Creates an array of an arbitrary sequence. Especially useful with builtin ranges.\r\n**`$.remove`**|Removes all elements from an array that the callback returns true.\r\n**`$.shuffle`**|Shuffles and returns the new shuffled array.\r\n**`$.slice`**|Slices the array based on the start and end position. If an end position is not specified it will slice till the end of the array.\r\n**`$.sortedIndex`**|Gives the smallest index at which a value should be inserted into a given the array is sorted.\r\n**`$.union`**|Creates an array of unique values, in order, of the provided arrays.\r\n**`$.uniq`**|Creates a duplicate-value-free version of an array.\r\n**`$.without`**|Creates an array excluding all provided values.\r\n**`$.xor`**|Creates an array that is the symmetric difference of the provided arrays.\r\n**`$.zip`**|Creates an array of grouped elements, the first of which contains the first elements of the given arrays.\r\n**`$.zipObject`**|Creates an object composed from arrays of keys and values.\r\n**`$.partition`**|Produces an array of arrays, each containing n elements, each offset by step. Stops after a partition is less than n length.\r\n**`$.partitionAll`**|Produces an array of arrays, each containing n elements, each offset by step. Continues after a partition is less than n length.\r\n**`$.partitionBy`**|Applies a function to each element in array, splitting it each time the function returns a new value.\r\n\r\n\r\n### Dictionary Methods ###\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`$.keys`**|Creates an array of keys given a dictionary.\r\n**`$.values`**|Creates an array of values given a dictionary\r\n**`$.merge`**|Merges all of the dictionaries together and the latter dictionary overrides the value at a given key\r\n**`$.pick`**|Creates a shallow clone of a dictionary composed of the specified keys.\r\n**`$.omit`**|Creates a shallow clone of a dictionary excluding the specified keys.\r\n\r\n### Object Methods ###\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`$.tap`**|Invokes interceptor with the object and then returns object.\r\n\r\n### Function Methods ###\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`$.after`**|Creates a function that executes passed function only after being called n times.\r\n**`$.bind`**|Creates a function that, when called, invokes func with the binding of arguments provided.\r\n**`$.id`**|The identify function which simply returns the argument its given.\r\n**`$.memoize`**|Returns a memoized function to improve performance by caching recursive function values.\r\n**`$.noop`**|A no-operation function.\r\n**`$.partial`**|Creates a function that, when called, invokes func with any additional partial arguments prepended to those provided to the new function.\r\n**`$.times`**|Call a function n times and also passes the index. If a value is returned in the function then the times method will return an array of those values.\r\n\r\n### Chaining ###\r\n\r\n**`$(array: ...)`**\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`any`**|Returns true if callback function returns true for at least one element in the array\r\n**`all`**|Returns true if callback function returns true for all elements in the array\r\n**`each`**|Passes each element value to the callback function\r\n**`filter`**|Filters the arrary to elements for which the callback function returns true\r\n**`first`**|Returns the first element in the array and terminated the chain\r\n**`second`**|Returns the second element in the array and terminated the chain\r\n**`third`**|Returns the third element in the array and terminated the chain\r\n**`flatten`**|Flattens a nested array of any depth.\r\n**`initial`**|Gets all but the last element or last n elements of an array.\r\n**`map`**|Maps each element to the new value returned in the callback function\r\n**`slice`**|Slices the array based on the start and end position. If an end position is not specified it will slice till the end of the array.\r\n**`value`**|Returns the value after evaluating all callbacks\r\n\r\n## Dollar Examples ##\r\n\r\n### Array ###\r\n\r\n### at - `$.at`\r\n\r\nCreates an array of elements from the specified indexes, or keys, of the collection. Indexes may be specified as individual arguments or as arrays of indexes.\r\n\r\n```swift\r\n$.at([\"ant\", \"bat\", \"cat\", \"dog\", \"egg\"], indexes: 0, 2, 4) \r\n=> [\"ant\", \"cat\", \"egg\"]\r\n```\r\n\r\n### compact - `$.compact`\r\n\r\nCreates an array with all nil values removed.\r\n\r\n```swift\r\n$.compact([3, nil, 4, 5]) \r\n=> [3, 4, 5]\r\n\r\n$.compact([nil, nil]) as NSObject[] \r\n=> []\r\n```\r\n\r\n### contains - `$.contains`\r\n\r\nChecks if a given value is present in the array.\r\n\r\n```swift\r\n$.contains([1, 2, 3, 1, 2, 3], value: 2) \r\n=> true\r\n\r\n$.contains([1, 2, 3, 1, 2, 3], value: 10) \r\n=> false\r\n```\r\n\r\n### difference - `$.difference`\r\n\r\nCreates an array excluding all values of the provided arrays\r\n\r\n```swift\r\n$.difference([1, 2, 3, 4, 5], [5, 2, 10]) \r\n=> [1, 3, 4]\r\n```\r\n\r\n\r\n### every - `$.every`\r\n\r\nChecks if the given callback returns true value for all items in the array.\r\n\r\n```swift\r\n$.every([1, 2, 3, 4], iterator: { $0 < 20 }) \r\n=> true\r\n\r\n$.every([1, 2, 3, 4]) { $0 == 1 } \r\n=> false\r\n```\r\n\r\n### find - `$.find`\r\n\r\nIterates over elements of an array and returning the first element that the callback returns true for.\r\n\r\n```swift\r\n$.find([1, 2, 3, 4], iterator: { $0 == 2 }) \r\n=> 2\r\n\r\n$.find([1, 2, 3, 4]) { $0 == 10 } \r\n=> nil\r\n```\r\n\r\n### findIndex - `$.findIndex`\r\n\r\nThis method is like find except that it returns the index of the first element that passes the callback check.\r\n\r\n```swift\r\nlet arr = [[\"age\": 36], [\"age\": 40], [\"age\": 1]]\r\nlet result = $.findIndex(arr) { $0[\"age\"] < 20 }\r\nresult \r\n=> 2\r\n```\r\n\r\n### findLastIndex - `$.findLastIndex`\r\n\r\nThis method is like findIndex except that it iterates over elements of the array from right to left.\r\n\r\n```swift\r\nlet arr = [[\"age\": 36], [\"age\": 40], [\"age\": 1]]\r\nlet result = $.findLastIndex(arr) { $0[\"age\"] > 30 }\r\nresult\r\n=> 1\r\n```\r\n\r\n### first - `$.first(array: AnyObject[])`\r\n\r\nGets the first element in the array.\r\n\r\n```swift\r\n$.first([1, 2, 3, 4])\r\n=> 1\r\n\r\n$.first([]) \r\n=> nil\r\n```\r\n\r\n### second - `$.second(array: AnyObject[])`\r\n\r\nGets the second element in the array.\r\n\r\n```\r\n$.second([1, 2, 3, 4])\r\n=> 2\r\n\r\n$.second([1]) \r\n=> nil\r\n\r\n$.second([])\r\n=> nil\r\n```\r\n\r\n### flatten - `$.flatten`\r\n\r\nFlattens a nested array of any depth.\r\n\r\n```swift\r\n$.flatten([[3], 4, 5]) as Int[] \r\n=> [3, 4, 5]\r\n\r\n$.flatten([[3], \"Hello\", 5]) as NSObject[] \r\n=> [3, \"Hello\", 5]\r\n\r\n$.flatten([[[3], 4], 5]) as Int[] \r\n=> [3, 4, 5]\r\n```\r\n\r\n### frequencies - `$.frequencies`\r\nThis method returns a dictionary of values in an array mapping to the total number of occurrences in the array. If passed a function it returns a frequency table of the results of the given function on the arrays elements.\r\n\r\n```swift\r\n$.frequencies([\"a\", \"a\", \"b\", \"c\", \"a\", \"b\"]) \r\n=> [\"a\": 3, \"b\": 2, \"c\": 1]\r\n\r\n$.frequencies([1, 2, 3, 4, 5]) { $0 % 2 == 0 }\r\n=> [false: 3, true: 2]\r\n```\r\n\r\n### indexof - `$.indexof`\r\n\r\nGets the index at which the first occurrence of value is found.\r\n\r\n```swift\r\n$.indexOf([1, 2, 3, 1, 2, 3], value: 2) \r\n=> 1\r\n\r\n$.indexOf([\"A\", \"B\", \"C\"], value: \"B\") \r\n=> 1\r\n\r\n$.indexOf([3, 4, 5], value: 5) \r\n=> 2\r\n\r\n$.indexOf([3, 4, 5], value: 3) \r\n=> 0\r\n\r\n$.indexOf([3, 4, 5], value: 2) \r\n=> nil\r\n```\r\n\r\n### initial - `$.initial`\r\n\r\nGets all but the last element or last n elements of an array.\r\n\r\n```swift\r\n$.initial([3, 4, 5]) \r\n=> [3, 4]\r\n\r\n$.initial([3, 4, 5], numElements: 2) \r\n=> [3]\r\n```\r\n\r\n### intersection - `$.intersection`\r\n\r\nCreates an array of unique values present in all provided arrays.\r\n\r\n```swift\r\n$.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]) \r\n=> [1, 2]\r\n```\r\n\r\n### last - `$.last`\r\n\r\nGets the last element from the array.\r\n\r\n```swift\r\n$.last([3, 4, 5]) \r\n=> 5\r\n```\r\n\r\n### lastIndexOf - `$.lastIndexOf`\r\n\r\nGets the index at which the last occurrence of value is found.\r\n\r\n```swift\r\n$.lastIndexOf([1, 2, 3, 1, 2, 3], value: 2) \r\n=> 4\r\n```\r\n\r\n### rest - `$.rest`\r\n\r\nThe opposite of initial this method gets all but the first element or first n elements of an array.\r\n\r\n```swift\r\n$.rest([3, 4, 5]) \r\n=> [4, 5]\r\n\r\n$.rest([3, 4, 5], numElements: 2) \r\n=> [5]\r\n```\r\n\r\n### min - `$.min`\r\n\r\nRetrieves the minimum value in an array.\r\n\r\n```swift\r\n$.min([2, 1, 2, 3, 4]) \r\n=> 1\r\n```\r\n\r\n### max - `$.max`\r\n\r\nRetrieves the maximum value in an array.\r\n\r\n```swift\r\n$.max([1, 2, 3, 4, 2, 1]) \r\n=> 4\r\n```\r\n\r\n### pluck - `$.pluck`\r\n\r\nRetrieves the value of a specified property from all elements in the array.\r\n\r\n```swift\r\nlet arr : Dictionary<String, Int>[] = [[\"age\": 20], [\"age\": 30], [\"age\": 40]]\r\n$.pluck(arr, value: \"age\") \r\n=> [20, 30, 40]\r\n```\r\n\r\n### pull - `$.pull`\r\n\r\nRemoves all provided values from the given array.\r\n\r\n```swift\r\n$.pull([3, 4, 5, 3, 5], values: 3, 5) \r\n=> [4]\r\n\r\n$.pull([3, 4, 5, 3, 5], values: 4) \r\n=> [3, 5, 3, 5]\r\n\r\n$.pull([3, 4, 5, 3, 5], values: 3, 4, 5) \r\n=> []\r\n```\r\n\r\n### range - `$.range`\r\n\r\nCreates an array of numbers (positive and/or negative) progressing from start up to but not including end.\r\n\r\n```swift\r\n$.range(4) \r\n=> [0, 1, 2, 3]\r\n\r\n$.range(from: 1, to: 5) \r\n=> [1, 2, 3, 4]\r\n\r\n$.range(from: 0, to: 20, incrementBy: 5) \r\n=> [0, 5, 10, 15]\r\n\r\n$.range(from: 1, through: 5)\r\n=> [1, 2, 3, 4, 5]\r\n\r\n$.range(from: 0, through: 20, incrementBy: 5)\r\n=> [0, 5, 10, 15, 20]\r\n```\r\n\r\n### sample - `$.sample`\r\n```\r\nlet arr : Int[] = [2, 1, 2, 3, 4]\r\n$.contains(arr, value: $.sample(arr))\r\n=> true\r\n```\r\n\r\n### sequence - `$.sequence`\r\n\r\nCreates an array of an arbitrary sequence. Especially useful with builtin ranges.\r\n\r\n```swift\r\n$.sequence(0..4) \r\n=> [0, 1, 2, 3]\r\n\r\n$.sequence(-2.0..2.0) \r\n=> [-2.0, -1.0, 0.0, 1.0]\r\n\r\n$.sequence((0..20).by(5)) \r\n=> [0, 5, 10, 15]\r\n\r\n$.sequence(\"abc\") \r\n=> [\"a\", \"b\", \"c\"]\r\n```\r\n\r\n### remove - `$.remove`\r\n\r\nRemoves all elements from an array that the callback returns true.\r\n\r\n```swift\r\nlet result = $.remove([1, 2, 3, 4, 5, 6]) { $0 == 2 || $0 == 3 }\r\nresult\r\n=> [1, 4, 5, 6]\r\n```\r\n\r\n### shuffle - `$.shuffle`\r\n\r\nShuffles and returns the new shuffled array\r\n\r\n```swift\r\nlet result = $.shuffle([1, 2, 3, 4, 5, 6])\r\nresult\r\n=> [4, 1, 3, 5, 6, 2]\r\n```\r\n\r\n### sortedIndex - `$.sortedIndex`\r\n\r\nGives the smallest index at which a value should be inserted into a given the array is sorted.\r\n\r\n```swift\r\n$.sortedIndex([3, 4, 6, 10], value: 5)\r\n=> 2\r\n\r\n$.sortedIndex([10, 20, 30, 50], value: 40)\r\n=> 3\r\n```\r\n\r\n### union - `$.union`\r\n\r\nCreates an array of unique values, in order, of the provided arrays.\r\n\r\n```swift\r\n$.union([1, 2, 3], [5, 2, 1, 4], [2, 1]) \r\n=> [1, 2, 3, 4, 5]\r\n```\r\n\r\n### merge - `$.merge`\r\n\r\nCreates an array of all values, including duplicates, of the arrays in the order they are provided.\r\n\r\n```swift\r\nlet arr  = [1, 5]\r\nlet arr2 = [2, 4]\r\nlet arr3 = [5, 6]\r\nlet result = $.merge(arrays: arr, arr2, arr3)\r\nresult\r\n=> [1, 5, 2, 4, 5, 6]\r\n```\r\n\r\n### uniq - `$.uniq`\r\n\r\nCreates a duplicate-value-free version of an array.\r\n\r\n```swift\r\n$.uniq([1, 2, 1, 3, 1])\r\n=> [1, 2, 3]\r\n```\r\n\r\n### without - `$.without`\r\n\r\nCreates an array excluding all provided values.\r\n\r\n```swift\r\n$.without([3, 4, 5, 3, 5], values: 3, 5)\r\n=> [4]\r\n\r\n$.without([3, 4, 5, 3, 5], values: 4)\r\n=> [3, 5, 3, 5]\r\n\r\n$.without([3, 4, 5, 3, 5], values: 3, 4, 5)\r\n=> []\r\n```\r\n\r\n### xor - `$.xor`\r\n\r\nCreates an array that is the symmetric difference of the provided arrays.\r\n\r\n```swift\r\n$.xor([1, 2, 3], [5, 2, 1, 4])\r\n=> [3, 4, 5]\r\n```\r\n\r\n### zip - `$.zip`\r\n\r\nCreates an array of grouped elements, the first of which contains the first elements of the given arrays.\r\n\r\n```swift\r\n$.zip([\"fred\", \"barney\"], [30, 40], [true, false]) as NSObject[] \r\n=> [[\"fred\", 30, true], [\"barney\", 40, false]]\r\n```\r\n\r\n### zipObject - `$.zipObject`\r\n\r\nCreates an object composed from arrays of keys and values.\r\n\r\n```swift\r\n$.zipObject([\"fred\", \"barney\"], values: [30, 40]) as Dictionary<String, Int> \r\n=> [\"fred\": 30, \"barney\": 40]\r\n```\r\n\r\n### partition - `$.partition`\r\n\r\nProduces an array of arrays, each containing n elements, each offset by step. Stops after a partition is less than n length.\r\n\r\n```swift\r\nlet arr = [1, 2, 3, 4, 5]\r\n$.partition(arr, n: 2)\r\n=> [[1, 2], [3, 4]]\r\n\r\n$.partition(arr, n: 4, step: 1)\r\n=> [[1, 2, 3, 4], [2, 3, 4, 5]]\r\n\r\n$.partition(arr, n: 4, step: 1, pad: nil)\r\n=> [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5]]\r\n\r\n$.partition(arr, n: 4, step: 1, pad: [6, 7, 8])\r\n=> [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]\r\n```\r\n\r\n### partitionAll - `$.partitionAll`\r\n\r\nProduces an array of arrays, each containing n elements, each offset by step. Continues after a partition is less than n length.\r\n\r\n```swift\r\n$.partitionAll([1, 2, 3, 4, 5], n:4, step: 1)\r\n=> [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5], [4, 5], [5]]\r\n```\r\n\r\n### partitionBy - `$.partitionBy`\r\n\r\nApplies a function to each element in array, splitting it each time the function returns a new value.\r\n\r\n```swift\r\n$.partitionBy([1, 2, 3, 4, 5]) { $0 % 2 == 0 }\r\n=> [[1], [2, 4], [3, 5], [6]]\r\n\r\n$.partitionBy([1, 7, 3, 6, 10, 12]) { $0 % 3 }\r\n=> [[1, 7], [3, 6], [10], [12]]\r\n```\r\n\r\n### Dictionary ###\r\n\r\n### keys - `$.keys`\r\n\r\nCreates an array of keys given a dictionary.\r\n\r\n```swift\r\n$.keys([\"Dog\": 1, \"Cat\": 2])\r\n=> [\"Dog\", \"Cat\"]\r\n```\r\n\r\n### values - `$.values`\r\n\r\nCreates an array of values given a dictionary\r\n\r\n```swift\r\n$.values([\"Dog\": 1, \"Cat\": 2])\r\n=> [1, 2]\r\n```\r\n\r\n### merge - `$.merge`\r\n\r\nMerges all of the dictionaries together and the latter dictionary overrides the value at a given key\r\n\r\n```swift\r\nlet dict: Dictionary<String, Int> = [\"Dog\": 1, \"Cat\": 2]\r\nlet dict2: Dictionary<String, Int> = [\"Cow\": 3]\r\nlet dict3: Dictionary<String, Int> = [\"Sheep\": 4]\r\n$.merge(dictionaries: dict, dict2, dict3)\r\n=> [\"Dog\": 1, \"Cat\": 2, \"Cow\": 3, \"Sheep\": 4]\r\n```\r\n\r\n### pick - `$.pick`\r\n\r\nCreates a shallow clone of a dictionary composed of the specified keys.\r\n\r\n```swift\r\n$.pick([\"Dog\": 1, \"Cat\": 2, \"Cow\": 3], keys: \"Dog\", \"Cow\")\r\n=> [\"Dog\": 1, \"Cow\": 3]\r\n```\r\n\r\n### omit - `$.omit`\r\n\r\nCreates a shallow clone of a dictionary excluding the specified keys.\r\n\r\n```swift\r\n$.omit([\"Dog\": 1, \"Cat\": 2, \"Cow\": 3], keys: \"Cat\", \"Dog\")\r\n=> [\"Cow\": 3, \"Sheep\": 4]\r\n```\r\n\r\n### Object ###\r\n\r\n### tap - `$.tap`\r\n\r\nInvokes interceptor with the object and then returns object.\r\n\r\n```swift\r\nvar beatle = Car(name: \"Fusca\")\r\n$.tap(beatle, {$0.name = \"Beatle\"}).color = \"Blue\"\r\n```\r\n\r\n### Function ###\r\n\r\n### after - `$.after`\r\n\r\nCreates a function that executes passed function only after being called n times.\r\n\r\n```swift\r\nvar saves = [\"profile\", \"settings\"];\r\nlet asyncSave = { (function: () -> ()?) in\r\n   function() // Saving right away for testing but in real world would be async\r\n}\r\nvar isDone = false\r\nvar completeCallback = $.after(saves.count) {\r\n   isDone = true\r\n}\r\nfor elem in saves {\r\n   asyncSave(completeCallback)\r\n}\r\nisDone \r\n=> true\r\n```\r\n\r\n### bind - `$.bind`\r\n\r\nCreates a function that, when called, invokes func with the binding of arguments provided.\r\n\r\n```swift\r\nlet helloWorldFunc = $.bind({(T...) in T[0] + \" \" + T[1] + \" from \" + T[2] }, \"Hello\", \"World\", \"Swift\")\r\nhelloWorldFunc() \r\n=> \"Hello World from Swift\"\r\n```\r\n\r\n### id - `$.id`\r\n\r\nThe identify function which simply returns the argument its given.\r\n\r\n```swift\r\n$.id(\"Hello World from Swift\")\r\n=> \"Hello World from Swift\"\r\n```\r\n\r\n### memoize - `$.memoize`\r\n\r\nReturns a memoized function to improve performance by caching recursive function values.\r\n\r\n```swift\r\nvar times = 0 // to test memoization\r\n\r\nlet fibMemo = $.memoize { (fib: (Int -> Int), val: Int) -> Int in\r\ntimes += 1\r\nreturn val == 1 || val == 0 ? 1 : fib(val - 1) + fib(val - 2)\r\n}\r\n\r\nlet x = fibMemo(5)\r\ntimes\r\n=> 6\r\n\r\ntimes = 0\r\nlet y = fibMemo(5)\r\ntimes\r\n=> 0\r\n\r\ntimes = 0\r\nlet z = fibMemo(6)\r\ntimes\r\n=> 1\r\n```\r\n\r\n### noop - `$.noop()`\r\n\r\nA no-operation function.\r\n\r\n```swift\r\n$.noop() \r\n=> nil\r\n```\r\n\r\n### partial - `$.partial`\r\n\r\nCreates a function that, when called, invokes func with any additional partial arguments prepended to those provided to the new function.\r\n\r\n```swift\r\nlet partialFunc = $.partial({(T...) in T[0] + \" \" + T[1] + \" from \" + T[2] }, \"Hello\")\r\npartialFunc(\"World\", \"Swift\") \r\n=> \"Hello World from Swift\"\r\n```\r\n\r\n### times - `$.times`\r\n\r\nCall a function n times and also passes the index. If a value is returned in the function then the times method will return an array of those values.\r\n\r\n```swift\r\nlet fun = $.bind({ (names: String...) -> String in\r\n   let people = $.join(names, separator: \" from \")\r\n   return \"Hello \\(people)\"\r\n   }, \"Ankur\", \"Swift\")\r\n$.times(2, function: fun) as String[] \r\n=> [\"Hello Ankur from Swift\", \"Hello Ankur from Swift\"]\r\n```\r\n\r\n### Chaining - `$(array: ...)`\r\n```swift\r\n$(array: [1, 2, 3])\r\n\r\n$(array: [1, 2, 3]).first().value()! as Int \r\n=> 1\r\n\r\n$(array: [[1, 2], 3, [[4], 5]]).flatten().initial(2).value()! as Int[] \r\n=> [1, 2, 3]\r\n\r\n$(array: [[1, 2], 3, [[4], 5]]).initial().flatten().first().value()! as Int \r\n=> 1\r\n\r\nvar chain = $(array: [10, 20, 30, 40, 50])\r\nvar elements: Int[] = []\r\nchain.each { elements += $0 as Int }\r\nelements as Int[] \r\n=> [10, 20, 30, 40, 50]\r\n\r\nvar chain = $(array: [10, 20, 30, 40, 50])\r\nchain.all({ ($0 as Int) < 100 }).value()! as Bool\r\n=> true\r\n\r\nchain.all({ ($0 as Int) < 40 }).value()! as Bool\r\n=> false\r\n\r\nchain.any({ ($0 as Int) < 40 }).value()! as Bool\r\n=> true\r\n```\r\n\r\n\r\n## Cent Usage ##\r\n\r\n### Array Extensions ###\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`at(indexes: Int...) -> [Element]`**| Creates an array of elements from the specified indexes, or keys, of the collection.\r\n**`every(iterator: (Element) -> Bool) -> Bool`**| Checks if the given callback returns true value for all items in the array.\r\n**`findIndex(iterator: (Element) -> Bool) -> Int?`**| This method is like find except that it returns the index of the first element that passes the callback check.\r\n**`findLastIndex(iterator: (Element) -> Bool) -> Int?`**| This method is like findIndex except that it iterates over elements of the array from right to left.\r\n**`first() -> Element?`**| Gets the first element in the array.\r\n**`flatten() -> [Element]`**| Flattens a nested array of any depth.\r\n**`get(index: Int) -> Element?`**| Get element at index\r\n**`initial(numElements: Int? = 1) -> [Element]`**| Gets all but the last element or last n elements of an array.\r\n**`last() -> Element?`**| Gets the last element from the array.\r\n**`rest(numElements: Int? = 1) -> [Element]`**| The opposite of initial this method gets all but the first element or first n elements of an array.\r\n**`min<T: Comparable>() -> T?`**| Retrieves the minimum value in an array.\r\n**`max<T: Comparable>() -> T?`**| Retrieves the maximum value in an array.\r\n\r\n### Date Extensions ###\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`Date.from(#year: Int, month: Int, day: Int) -> NSDate`**| Returns a new Date given the year month and day\r\n**`Date.parse(dateStr: String, format: String = \"yyyy-MM-dd\") -> NSDate`**| Parses the date based on the format and return a new Date\r\n**`Date.unix(date: NSDate = NSDate()) -> Double`**| Returns the unix timestamp of the date passed in or the current unix timestamp\r\n\r\n### Dictionary Extensions ###\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`isEmpty () -> Bool`**| Checks whether Dictionary has no keys and hence is empty\r\n**`merge<K, V>(dictionaries: Dictionary<K, V>...)`**| Merges the dictionary with dictionaries passed. The latter dictionaries will override values of the keys that are already set\r\n\r\n### Int Extensions ###\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`times(callback: (Int) -> ())`**| Invoke a callback n times with callback that takes index\r\n**`times (function: () -> ())`**| Invoke a callback n times\r\n\r\n### String Extensions ###\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`[i: Int] -> Character?`**| Get character at a subscript\r\n**`[r: Range<Int>] -> String`**| Get substring using subscript notation and by passing a range\r\n**`split(delimiter: Character) -> [String]`**| Get an array from string split using the delimiter character\r\n\r\n### Range Extensions ###\r\n\r\nMethod | Usage\r\n---- | ---------\r\n**`eachWithIndex(callback: (T) -> ())`**| For each index in the range invoke the callback by passing the item in range\r\n**`each(callback: () -> ())`**| For each index in the range invoke the callback\r\n**`==`**| Check the equality of two ranges\r\n\r\n## Cent Examples ##\r\n\r\n### Array Example Usage ###\r\n```swift\r\nlet array = [\"foo\", \"spam\", \"bar\", \"eggs\"]\r\nlet some = array.at(1, 3)\r\n=> [\"spam\", \"eggs\"]\r\n\r\n[\"angry\", \"hungry\"].every { (a: String) -> (Bool) in a.hasSuffix(\"gry\") }\r\n=> true\r\n\r\nlet ind: int? = [\"foo\", \"bar\", \"spam\", \"eggs\"].findIndex({ $0.length == 4 })\r\nind! == 2 \r\n=> true\r\n\r\nlet ind: int? = [\"foo\", \"bar\", \"spam\", \"eggs\"].findLastIndex({ $0.length == 4 })\r\nind! == 3 \r\n=> true\r\n\r\nlet first = [\"foo\", \"bar\"].first()\r\n=> \"foo\"\r\n\r\nlet unFlattened = [\"foo\", [\"bar\"], [[\"spam\"]], [[[\"eggs\"]]] ]\r\nlet flattened = unFlattened.flatten() \r\n=> [\"foo\", \"bar\", \"spam\", \"eggs\"]\r\n\r\nlet element = [\"foo\", \"bar\"].get(0)\r\nelement!\r\n=> \"foo\"\r\n\r\nlet nothing = [\"foo\", \"bar\"].get(1000)\r\n=> nil\r\n\r\nlet initial = [\"foo\", \"bar\", \"spam\"].initial(2) \r\n=> [\"foo\"]\r\n\r\nlet last = [\"foo\", \"bar\"].last() \r\n=> \"bar\"\r\n\r\nlet rest = [\"foo\", \"bar\", \"spam\"].rest(2)\r\n=> [\"spam\"]\r\n\r\nlet min = [ 0, 1, 2 ].min()\r\n=> 0\r\n\r\nlet max = [ 0, 1, 2].max()\r\n=> 2\r\n```\r\n\r\n### Date Example Usage ###\r\n```swift\r\nlet date = Date.from(2014, 1, 1) \r\n=> \"Jan 1, 2014, 12:00 AM\"\r\n\r\nlet parsedDate = Date.parse(\"2014-01-01\", format: \"yyyy-MM-dd\")\r\n=> \"Jan 1, 2014, 12:00 AM\"\r\n\r\nlet currentUnix = Date.unix()\r\n=> 1,412,829,874.07114\r\n\r\nvar otherNSDate = Date()\r\nlet otherUnix = Date.unix(otherDate)\r\n=> 1,412,829,938.92399\r\n```\r\n\r\n### Dictionary Example Usage ###\r\n```swift\r\nlet dictionary = [String: String]()\r\ndictionary.isEmpty() \r\n=> true\r\n\r\n[\"foo\": \"bar\"].isEmpty() \r\n=> false\r\n\r\nvar dic = [\"foo\": \"bar\"] \r\nlet anotherDic = [\"foo\": \"baz\", \"spam\": \"eggs\"]\r\ndic.merge(anotherDic)\r\n=> [\"foo\": \"baz\", \"spam\": \"eggs\"]\r\n```\r\n\r\n### Int Example Usage ###\r\n```swift\r\n5.times { print(\"Na\") } \r\n=> NaNaNaNaNa\r\n\r\n5.times { (a: Int) -> () in print(\"\\(a) \") } \r\n=> 0 1 2 3 4  \r\n```\r\n\r\n### String Example Usage ###\r\n```swift\r\n\"Hello World\"[6] == \"W\"\r\n=> true\r\n\r\n\"Hello World\"[0..<5] == \"Hello\" \r\n=> true\r\n\r\n\"Hello World\".split(\" \") \r\n=> [\"Hello\", \"World\"]\r\n\r\n\"Hi\"[5]\r\n=> nil\r\n```\r\n\r\n### Range Example Usage ###\r\n```swift\r\n(1...5).eachWithIndex { (a: Int) -> () in print(\"\\(a)\") } \r\n=> 12345\r\n\r\n(1...5).each { print('Na') } \r\n=> NaNaNaNaNa\r\n\r\n(1...5) == (1...5) \r\n=> true\r\n\r\n(1..<5) == (1...5) \r\n=> false\r\n```\r\n\r\n## Contributing ##\r\nIf you are interested in contributing checkout [CONTRIBUTING.md](CONTRIBUTING.md)\r\n\r\n## Roadmap ##\r\n\r\n* More functions such as curry function and then ability to lazily evaluate chained expressions.\r\n* Add extention functions to the Cent library\r\n\r\n\r\n### Dollar or Cent ###\r\nIf you are interested only in pure functional programming `import Dollar` otherwise `import Cent` which includes extensions for certain object type such as Array for now but more will be added.\r\n","google":"UA-51727665-1","note":"Don't delete this file! It's used internally to help with page regeneration."}