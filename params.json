{"name":"Dollar.swift","tagline":"A functional tool-belt for Swift Language similar to Lo-Dash or Underscore in Javascript","body":"<h1 style=\"font-weight:100;\">$ is a Swift library that provides useful functional programming helper methods without extending any built in objects.</h1>\r\n<pre>\r\n     ___\r\n   _|\\  \\__\r\n  |\\   ____\\\r\n  \\ \\  \\___|_\r\n   \\ \\_____  \\\r\n    \\|____|\\  \\\r\n      ____\\_\\  \\\r\n     |\\___    __\\\r\n     \\|___|\\__\\_|\r\n          \\|__|     \r\n</pre>\r\n\r\n### Setup\r\nInclude the `Dollar.swift` into your project and import the library using `import Dollar`\r\n\r\nCurrently there are issues loading the library using `pod 'Dollar', '~> 0.2'`\r\n\r\n### Contributing\r\nIf you are interested in contributing\r\n\r\n1. Please fork this project\r\n2. Implement new methods or changes in the `Dollar.swift` file in the Classes folder\r\n3. Write tests in `DollarTests.swift` file in the DollarTests folder\r\n4. Submit a pull request.\r\n\r\n### Array Helper Methods\r\n\r\n* $.first\r\n* $.compact\r\n* $.contains\r\n* $.difference\r\n* $.findIndex\r\n* $.findLastIndex\r\n* $.flatten\r\n* $.frequencies\r\n* $.indexOf\r\n* $.initial\r\n* $.intersection\r\n* $.last\r\n* $.lastIndexOf\r\n* $.rest\r\n* $.noop\r\n* $.pull\r\n* $.range\r\n* $.remove\r\n* $.sortedIndex\r\n* $.union\r\n* $.uniq\r\n* $.without\r\n* $.xor\r\n* $.zip\r\n* $.zipObject\r\n\r\n### Collection Helper Methods\r\n* $.at\r\n* $.every\r\n* $.find\r\n* $.min\r\n* $.max\r\n* $.pluck\r\n\r\n### Dictionary Helper Methods\r\n\r\n* $.keys\r\n* $.values\r\n* $.merge\r\n* $.pick\r\n* $.omit\r\n\r\n### Object Helper Methods\r\n\r\n* $.tap\r\n\r\n### Chaining\r\n* $(array: ...)\r\n* `$(array: [1, 2, 3]).first() as Int == 1`\r\n* `$(array: [[1, 2], 3, [[4], 5]]).flatten().initial(2).value() as Int[] == [1, 2, 3]`\r\n* `$(array: [[1, 2], 3, [[4], 5]]).initial().flatten().first() as Int == 1`\r\n* ...\r\n\r\n### Roadmap\r\n\r\nMore functions will be added and then ability to chain operations and lazily evaluation of chained expressions.\r\n\r\n###Usage\r\n\r\n`$.first([1, 2, 3, 4]) as Double == 1`\r\n\r\n`$.first([]) == nil`\r\n\r\n`$.noop() == nil`\r\n\r\n`$.compact([3, nil, 4, 5]) as NSObject[] == [3, 4, 5]`\r\n\r\n`$.compact([nil, nil]) as NSObject[] == []`\r\n\r\n`$.flatten([[3], 4, 5]) as Int[] == [3, 4, 5]`\r\n\r\n`$.flatten([[3], \"Hello\", 5]) as NSObject[] == [3, \"Hello\", 5]`\r\n\r\n`$.flatten([[[3], 4], 5]) as Int[] == [3, 4, 5]`\r\n\r\n`$.indexOf([\"A\", \"B\", \"C\"], value: \"B\") == 1`\r\n\r\n`$.indexOf([3, 4, 5], value: 5) == 2`\r\n\r\n`$.indexOf([3, 4, 5], value: 3) == 0`\r\n\r\n`$.indexOf([3, 4, 5], value: 2) == nil`\r\n\r\n`$.initial([3, 4, 5]) as Int[] == [3, 4]`\r\n\r\n`$.initial([3, 4, 5], numElements: 2) as Int[] == [3]    `\r\n\r\n`$.rest([3, 4, 5]) as Int[] == [4, 5]`\r\n\r\n`$.rest([3, 4, 5], numElements: 2) as Int[] == [5]`\r\n\r\n`$.last([3, 4, 5]) as Int == 5`\r\n\r\n```\r\nlet arr = [[\"age\": 36], [\"age\": 40], [\"age\": 1]]\r\nlet result = $.findIndex(arr) { $0[\"age\"] < 20 }\r\nresult == 2\r\n```\r\n\r\n```\r\nlet arr = [[\"age\": 36], [\"age\": 40], [\"age\": 1]]\r\nlet result = $.findLastIndex(arr) { $0[\"age\"] > 30 }\r\nresult == 1\r\n```\r\n\r\n`$.indexOf([1, 2, 3, 1, 2, 3], value: 2) == 1`\r\n\r\n`$.lastIndexOf([1, 2, 3, 1, 2, 3], value: 2) == 4`\r\n\r\n`$.contains([1, 2, 3, 1, 2, 3], value: 2) == true`\r\n\r\n`$.contains([1, 2, 3, 1, 2, 3], value: 10) == false``\r\n\r\n`$.frequencies([\"a\", \"a\", \"b\", \"c\", \"a\", \"b\"]) == [\"a\": 3, \"b\": 2, \"c\": 1]`\r\n\r\n`$.range(4) as Int[] == [0, 1, 2, 3]`\r\n\r\n`$.range(1, endVal: 5) as Int[] == [1, 2, 3, 4]`\r\n\r\n`$.range(0, endVal: 20, incrementBy: 5) as Int[] == [0, 5, 10, 15]`\r\n\r\n```\r\nlet result = $.remove([1, 2, 3, 4, 5, 6], iterator: { $0 as Int == 2 || $0 as Int == 3 })\r\nresult as Int[] == [1, 4, 5, 6]\r\n```\r\n\r\n`$.sortedIndex([3, 4, 6, 10], value: 5) as Int == 2`\r\n\r\n`$.sortedIndex([10, 20, 30, 50], value: 40) as Int == 3`\r\n\r\n`$.without([3, 4, 5, 3, 5], values: 3, 5) as Int[] == [4]`\r\n\r\n`$.without([3, 4, 5, 3, 5], values: 4) as Int[] == [3, 5, 3, 5]`\r\n\r\n`$.without([3, 4, 5, 3, 5], values: 3, 4, 5) as Int[] == []`\r\n\r\n`$.pull([3, 4, 5, 3, 5], values: 3, 5) as Int[] == [4]`\r\n\r\n`$.pull([3, 4, 5, 3, 5], values: 4) as Int[] == [3, 5, 3, 5]`\r\n\r\n`$.pull([3, 4, 5, 3, 5], values: 3, 4, 5) as Int[] == []`\r\n\r\n`$.zip([\"fred\", \"barney\"], [30, 40], [true, false]) as NSObject[] == [[\"fred\", 30, true], [\"barney\", 40, false]]`\r\n\r\n`$.zipObject([\"fred\", \"barney\"], values: [30, 40]) as Dictionary<String, Int> == [\"fred\": 30, \"barney\": 40]`\r\n\r\n`$.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]) as Int[] == [1, 2]`\r\n\r\n`$.difference([1, 2, 3, 4, 5], [5, 2, 10]) as Int[] == [1, 3, 4]`\r\n\r\n`$.uniq([1, 2, 1, 3, 1]) as Int[] == [1, 2, 3]`\r\n\r\n`$.union([1, 2, 3], [5, 2, 1, 4], [2, 1]) as Int[] == [1, 2, 3, 4, 5]`\r\n\r\n`$.xor([1, 2, 3], [5, 2, 1, 4]) as Int[] == [3, 4, 5]`\r\n\r\n`$.at([\"ant\", \"bat\", \"cat\", \"dog\", \"egg\"], indexes: 0, 2, 4) as String[] == [\"ant\", \"cat\", \"egg\"]`\r\n\r\n`$.every([1, 2, 3, 4], iterator: { $0 < 20 }) == true`\r\n\r\n`$.every([1, 2, 3, 4], iterator: { $0 == 1 }) == false`\r\n\r\n`$.find([1, 2, 3, 4], iterator: { $0 == 2 }) == 2`\r\n\r\n`$.find([1, 2, 3, 4], iterator: { $0 == 10 }) == nil`\r\n\r\n`$.max([1, 2, 3, 4, 2, 1]) == 4`\r\n\r\n`$.min([2, 1, 2, 3, 4]) == 1`\r\n\r\n```\r\nlet arr : Int[] = [2, 1, 2, 3, 4]\r\n$.contains(arr, value: $.sample(arr) as NSObject)\r\n```\r\n\r\n```\r\nlet arr : Dictionary<String, Int>[] = [[\"age\": 20], [\"age\": 30], [\"age\": 40]]\r\n$.pluck(arr, value: \"age\") == [20, 30, 40]\r\n```\r\n\r\n`$.keys([\"Dog\": 1, \"Cat\": 2])`\r\n\r\n`$.values([\"Dog\": 1, \"Cat\": 2])`\r\n\r\n```\r\nlet dict: Dictionary<String, Int> = [\"Dog\": 1, \"Cat\": 2]\r\nlet dict2: Dictionary<String, Int> = [\"Cow\": 3]\r\nlet dict3: Dictionary<String, Int> = [\"Sheep\": 4]\r\n$.merge(dict, dictionaries: dict2, dict3)\r\n```\r\n\r\n`$.pick([\"Dog\": 1, \"Cat\": 2, \"Cow\": 3], keys: \"Dog\", \"Cow\")`\r\n\r\n`$.omit([\"Dog\": 1, \"Cat\": 2, \"Cow\": 3], keys: \"Cat\", \"Dog\")`\r\n\r\n```\r\nvar beatle = Car(name: \"Fusca\")\r\n$.tap(beatle, {$0.name = \"Beatle\"}).color = \"Blue\"\r\n```\r\n\r\n### Why not extend the collection type?\r\n1. The project doesnt extend the collection using the extension features to keep it purely functional and\r\n2. To not override any methods via extensions if Apple decides to add those methods into the collection class themselves as part of the language update. This could lead to inconsistent behavior for those who use the library and those who don't.\r\n\r\n","google":"UA-51727665-1","note":"Don't delete this file! It's used internally to help with page regeneration."}